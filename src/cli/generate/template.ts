import fs from 'node:fs/promises';
import path from 'node:path';
import type { ServerDefinition } from '../../config.js';
import type { GeneratedOption, ToolMetadata } from './tools.js';
import { buildEmbeddedSchemaMap } from './tools.js';

export interface TemplateInput {
  outputPath?: string;
  runtimeKind: 'node' | 'bun';
  timeoutMs: number;
  definition: ServerDefinition;
  serverName: string;
  tools: ToolMetadata[];
  generator: {
    name: string;
    version: string;
  };
}

export async function writeTemplate(input: TemplateInput): Promise<string> {
  const resolvedOutput = input.outputPath
    ? path.resolve(input.outputPath)
    : path.resolve(process.cwd(), `${input.serverName}.ts`);
  await fs.mkdir(path.dirname(resolvedOutput), { recursive: true });
  await fs.writeFile(resolvedOutput, renderTemplate(input), 'utf8');
  await fs.chmod(resolvedOutput, 0o755);
  return resolvedOutput;
}

export async function readPackageMetadata(): Promise<{ name: string; version: string }> {
  const packageJsonPath = path.resolve(process.cwd(), 'package.json');
  const buffer = await fs.readFile(packageJsonPath, 'utf8');
  const pkg = JSON.parse(buffer) as { name?: string; version?: string };
  return {
    name: pkg.name ?? 'mcporter',
    version: pkg.version ?? '0.0.0',
  };
}

export function renderTemplate({
  runtimeKind,
  timeoutMs,
  definition,
  serverName,
  tools,
  generator,
}: TemplateInput): string {
  const imports = [
    "import { Command } from 'commander';",
    "import { createRuntime, createServerProxy } from 'mcporter';",
    "import { createCallResult } from 'mcporter';",
  ].join('\n');
  const embedded = JSON.stringify(definition, (_key, value) => (value instanceof URL ? value.toString() : value), 2);
  const generatorHeader = `Generated by ${generator.name}@${generator.version} â€” https://github.com/steipete/mcporter`;
  const toolHelpLines = tools
    .map((tool) => `  ${tool.tool.name}${tool.tool.description ? ` - ${tool.tool.description}` : ''}`)
    .join('\n');
  const generatorHeaderLiteral = JSON.stringify(generatorHeader);
  const toolHelpLiteral = JSON.stringify(toolHelpLines);
  const embeddedSchemas = JSON.stringify(buildEmbeddedSchemaMap(tools), undefined, 2);
  const renderedTools = tools.map((tool) => renderToolCommand(tool, timeoutMs));
  const toolBlocks = renderedTools.map((entry) => entry.block).join('\n\n');
  const signatureMap = Object.fromEntries(renderedTools.map((entry) => [entry.commandName, entry.signature]));
  const signatureMapLiteral = JSON.stringify(signatureMap, undefined, 2);
  return `#!/usr/bin/env ${runtimeKind === 'bun' ? 'bun' : 'node'}
${imports}

const embeddedServer = ${embedded} as const;
const embeddedSchemas = ${embeddedSchemas} as const;
const embeddedName = ${JSON.stringify(serverName)};
const generatorInfo = ${generatorHeaderLiteral};
const generatorTools = ${toolHelpLiteral};
const program = new Command();
program.name(embeddedName);
program.description('Standalone CLI generated for the ' + embeddedName + ' MCP server.');
program.option('-c, --config <path>', 'Alternate mcporter.json path to load server definition.');
program.option('-s, --server <name>', 'Alternate server name when using --config.');
program.option('-t, --timeout <ms>', 'Call timeout in milliseconds', (value) => parseInt(value, 10), ${timeoutMs});
program.option('-o, --output <format>', 'Output format: text|markdown|json|raw', 'text');
const commandSignatures: Record<string, string> = ${signatureMapLiteral};
program.configureHelp({
\tcommandTerm(cmd) {
\t\tconst term = cmd.name();
\t\treturn commandSignatures[term] ?? cmd.name();
\t},
});
program.addHelpText('after', () => {
\tconst sections: string[] = [];
\tif (generatorTools) {
\t\tsections.push('\\nTools:\\n' + generatorTools + '\\n');
\t}
\tif (generatorInfo) {
\t\tsections.push('\\n' + generatorInfo + '\\n');
\t}
\treturn sections.join('');
});

${toolBlocks}

program.command('list-tools')
\t.description('List available tools for this CLI')
\t.action(() => {
\t\tconsole.log('Available tools:');
\t\t${JSON.stringify(
    tools.map((tool) => ({
      name: tool.tool.name,
      description: tool.tool.description ?? '',
    })),
    null,
    2
  )}.forEach((entry) => {
\t\t\tconsole.log(' - ' + entry.name + (entry.description ? ' - ' + entry.description : ''));
\t\t});
\t});

program.parseAsync(process.argv).catch((error) => {
\tconsole.error(error instanceof Error ? error.message : error);
\tprocess.exit(1);
});

async function ensureRuntime(globalOptions: { config?: string; server?: string; timeout: number }) {
\tif (globalOptions.config) {
\t\tconst runtime = await createRuntime({ configPath: globalOptions.config });
\t\tconst name = globalOptions.server ?? embeddedName;
\t\treturn { runtime, serverName: name, usingEmbedded: false };
\t}
\tif (globalOptions.server && globalOptions.server !== embeddedName) {
\t\tthrow new Error('Server override not found in embedded definition. Provide --config pointing to a file that contains the server.');
\t}
\tconst definition = normalizeEmbeddedServer(embeddedServer);
\tconst runtime = await createRuntime({ servers: [definition] });
\treturn { runtime, serverName: embeddedName, usingEmbedded: true };
}

async function invokeWithTimeout<T>(promise: Promise<T>, timeout: number): Promise<T> {
\treturn await Promise.race([
\t\tpromise,
\t\tnew Promise<T>((_, reject) => {
\t\t\tsetTimeout(() => reject(new Error('MCP call timed out after ' + timeout + 'ms')), timeout);
\t\t}),
\t]);
}

function printResult(result: unknown, format: string) {
\tconst wrapped = createCallResult(result);
\tswitch (format) {
\t\tcase 'json': {
\t\t\tconst json = wrapped.json();
\t\t\tif (json) {
\t\t\t\tconsole.log(JSON.stringify(json, null, 2));
\t\t\t\treturn;
\t\t\t}
\t\t\tbreak;
\t\t}
\t\tcase 'markdown': {
\t\t\tconst markdown = wrapped.markdown();
\t\t\tif (markdown) {
\t\t\t\tconsole.log(markdown);
\t\t\t\treturn;
\t\t\t}
\t\t\tbreak;
\t\t}
\t\tcase 'raw': {
\t\t\tconsole.log(JSON.stringify(wrapped.raw, null, 2));
\t\t\treturn;
\t\t}
\t}
\tconst text = wrapped.text();
\tif (text) {
\t\tconsole.log(text);
\t} else {
\t\tconsole.log(JSON.stringify(wrapped.raw, null, 2));
\t}
}

function normalizeEmbeddedServer(server: typeof embeddedServer) {
\tconst base = { ...server } as Record<string, unknown>;
\tif ((server.command as any).kind === 'http') {
\t\tconst urlRaw = (server.command as any).url;
\t\tconst urlValue = typeof urlRaw === 'string' ? urlRaw : String(urlRaw);
\t\treturn {
\t\t\t...base,
\t\t\tcommand: {
\t\t\t\t...(server.command as Record<string, unknown>),
\t\t\t\turl: new URL(urlValue),
\t\t\t},
\t\t};
\t}
\tif ((server.command as any).kind === 'stdio') {
\t\treturn {
\t\t\t...base,
\t\t\tcommand: {
\t\t\t\t...(server.command as Record<string, unknown>),
\t\t\t\targs: [ ...((server.command as any).args ?? []) ],
\t\t\t},
\t\t};
\t}
\treturn base;
}
`;
}

export function renderToolCommand(
  tool: ToolMetadata,
  defaultTimeout: number
): { block: string; commandName: string; signature: string } {
  const commandName = tool.tool.name.replace(/[^a-zA-Z0-9-]/g, '-');
  const description = tool.tool.description ?? `Invoke the ${tool.tool.name} tool.`;
  const optionLines = tool.options.map((option) => renderOption(option)).join('\n');
  const usageParts = tool.options.map((option) =>
    option.required ? `--${option.cliName} ${option.placeholder}` : `[--${option.cliName} ${option.placeholder}]`
  );
  usageParts.push('[--raw <json>]');
  const usageLine = usageParts.length ? usageParts.join(' ') : '';
  const usageSnippet = usageLine ? `.usage(${JSON.stringify(usageLine)})\n` : '';
  const buildArgs = tool.options
    .map((option) => {
      const source = `cmdOpts.${option.property}`;
      return `if (${source} !== undefined) args.${option.property} = ${source};`;
    })
    .join('\n\t\t');
  const signature = usageLine ? `${commandName} ${usageLine}` : commandName;
  const exampleInvocation = buildExampleInvocation(commandName, tool.options);
  const exampleSnippet = exampleInvocation
    ? `\n\t.addHelpText('after', () => '\\nExample:\\n  ' + ${exampleInvocation})`
    : '';
  const block = `program
\t.command(${JSON.stringify(commandName)})
\t.summary(${JSON.stringify(signature)})
\t.description(${JSON.stringify(description)})
${usageSnippet ? `\t${usageSnippet}` : ''}\t.option('--raw <json>', 'Provide raw JSON arguments to the tool, bypassing flag parsing.')
${optionLines ? `\n${optionLines}` : ''}
\t.action(async (cmdOpts) => {
\t\tconst globalOptions = program.opts();
\t\tconst { runtime, serverName, usingEmbedded } = await ensureRuntime({
\t\t\tconfig: globalOptions.config,
\t\t\tserver: globalOptions.server,
\t\t\ttimeout: globalOptions.timeout || ${defaultTimeout},
\t\t});
\t\tconst proxy = createServerProxy(runtime, serverName, {
\t\t\tinitialSchemas: usingEmbedded ? embeddedSchemas : undefined,
\t\t});
\t\ttry {
\t\t\tconst args = cmdOpts.raw ? JSON.parse(cmdOpts.raw) : ({} as Record<string, unknown>);
\t\t\t${buildArgs}
\t\t\tconst call = (proxy.${tool.methodName} as any)(args);
\t\t\tconst result = await invokeWithTimeout(call, globalOptions.timeout || ${defaultTimeout});
\t\t\tprintResult(result, globalOptions.output ?? 'text');
\t\t} finally {
\t\t\tawait runtime.close(serverName).catch(() => {});
\t\t}
\t})${exampleSnippet};`;
  return { block, commandName, signature };
}

function renderOption(option: GeneratedOption): string {
  const flag = `--${option.cliName} ${option.placeholder}`;
  let description = option.description ? option.description : `Set ${option.property}.`;
  const detailParts: string[] = [];
  if (option.enumValues && option.enumValues.length > 0) {
    detailParts.push(`choices: ${option.enumValues.join(', ')}`);
  }
  if (option.defaultValue !== undefined) {
    detailParts.push(`default: ${formatHelpValue(option.defaultValue)}`);
  }
  if (option.exampleValue) {
    detailParts.push(`example: ${option.exampleValue}`);
  }
  if (detailParts.length > 0) {
    description += ` (${detailParts.join('; ')})`;
  }
  const parser = optionParser(option);
  const base = option.required
    ? `.requiredOption(${JSON.stringify(flag)}, ${JSON.stringify(description)}${parser ? `, ${parser}` : ''})`
    : `.option(${JSON.stringify(flag)}, ${JSON.stringify(description)}${parser ? `, ${parser}` : ''})`;
  return `	${base}`;
}

function buildExampleInvocation(commandName: string, options: GeneratedOption[]): string | undefined {
  const required = options.filter((option) => option.required);
  const chosen = required.length > 0 ? required : options.slice(0, Math.min(options.length, 2));
  const parts = [commandName, ...chosen.flatMap((option) => [`--${option.cliName}`, pickExampleValue(option)])].filter(
    Boolean
  ) as string[];
  if (parts.length === 0) {
    return undefined;
  }
  return JSON.stringify(parts.join(' '));
}

function pickExampleValue(option: GeneratedOption): string {
  if (option.exampleValue) {
    return option.exampleValue;
  }
  if (option.enumValues && option.enumValues.length > 0) {
    const [first] = option.enumValues;
    return first ?? option.property;
  }
  switch (option.type) {
    case 'number':
      return '1';
    case 'boolean':
      return 'true';
    case 'array':
      return 'value1,value2';
    default:
      if (option.property.toLowerCase().includes('path')) {
        return '/path/to/file.md';
      }
      if (option.property.toLowerCase().includes('id')) {
        return 'example-id';
      }
      return option.property;
  }
}

function formatHelpValue(value: unknown): string {
  if (Array.isArray(value)) {
    return value.map((entry) => String(entry)).join(', ');
  }
  if (value instanceof Date) {
    return value.toISOString();
  }
  if (value && typeof value === 'object') {
    return JSON.stringify(value);
  }
  return String(value);
}

function optionParser(option: GeneratedOption): string | undefined {
  switch (option.type) {
    case 'number':
      return '(value) => parseFloat(value)';
    case 'boolean':
      return "(value) => value !== 'false'";
    case 'array':
      return "(value) => value.split(',')";
    default:
      return undefined;
  }
}
